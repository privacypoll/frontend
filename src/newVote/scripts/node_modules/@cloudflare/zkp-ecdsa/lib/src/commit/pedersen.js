var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { jsonMember, jsonObject, toJson } from 'typedjson';
import { Group } from '../curves/group.js';
export class Commitment {
    constructor(p, r) {
        this.p = p;
        this.r = r;
    }
    add(c) {
        return new Commitment(this.p.add(c.p), this.r.add(c.r));
    }
    mul(k) {
        const sk = this.p.group.newScalar(k);
        return new Commitment(this.p.mul(sk), this.r.mul(sk));
    }
    sub(c) {
        return new Commitment(this.p.sub(c.p), this.r.sub(c.r));
    }
}
let PedersenParams = class PedersenParams {
    constructor(c, g, h) {
        this.c = c;
        this.g = g;
        this.h = h;
    }
    eq(o) {
        return this.c.eq(o.c) && this.g.eq(o.g) && this.h.eq(o.h);
    }
    commit(input) {
        const r = this.c.randomScalar(), v = this.c.newScalar(input), p = this.h.dblmul(r, this.g, v);
        return new Commitment(p, r);
    }
};
__decorate([
    jsonMember({ constructor: Group, isRequired: true }),
    __metadata("design:type", Group)
], PedersenParams.prototype, "c", void 0);
__decorate([
    jsonMember({ constructor: Group.Point, isRequired: true }),
    __metadata("design:type", Group.Point)
], PedersenParams.prototype, "g", void 0);
__decorate([
    jsonMember({ constructor: Group.Point, isRequired: true }),
    __metadata("design:type", Group.Point)
], PedersenParams.prototype, "h", void 0);
PedersenParams = __decorate([
    jsonObject,
    toJson,
    __metadata("design:paramtypes", [Group, Group.Point, Group.Point])
], PedersenParams);
export { PedersenParams };
export function generatePedersenParams(c, g) {
    if (!g) {
        g = c.generator();
    }
    const r = c.randomScalar(), h = g.mul(r);
    return new PedersenParams(c, g, h);
}
//# sourceMappingURL=pedersen.js.map